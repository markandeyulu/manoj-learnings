IOC - In configuration class, we will have component scan -- whatever packages under wit, will be scanned for @component tag and that will be stored in spring container 
	and we can get that with getBean method of context.
	
Dependency injection : 

A bean which is already present in Spring container will be placed in another bean without calling "new" or getBean method. 
That will be injected automatically.

2 types : 
1. Constructor based
2. Setter based

Constructor based : 
In any class, when it get instantiated, If that class constructor has only the already present object from container, that will be injected. 

I am calling RentalService rentalService1 = (RentalService) context.getBean(RentalService.class);
Ex 
	RentalService(StoreLocater storeLocator) {
		this.storeLocator = storeLocator;
	}
	
	or 
	
		RentalService(StoreLocater storeLocator, StoreLocater test) {
		this.storeLocator = storeLocator;
		this.test = test;
	}
	
But below is not allowed since String is not a qualifying bean
RentalService(StoreLocater storeLocator, String test) {
		this.storeLocator = storeLocator;
		this.test = test;
	}
	
-- If 2 valid constructors present, compiler will look for default constructor only. 


Setter based injection : 
		
		RentalService rentalService1 = (RentalService) context.getBean(RentalService.class);		
		rentalService1.setStoreLocator(context.getBean(StoreLocater.class));  //context.getBean(StoreLocater.class) -- we do get the bean object from ontainer manually
		
		public void setStoreLocator(StoreLocater storeLocator) {
		System.out.println("Setter called");
		this.storeLocator = storeLocator;
			}
			
Autowired can be a replacement for both the above approaches : We can do the same simply using autowired
	@Autowired
	private StoreLocater storeLocator;
	
**Autowire - is not for premitive types and only for objects
	
Bean : 
What is Bean ? 
	Instead of compiler scans component on every class, we also can tell container to create a bean for a class and store it in a container. 
	
	During bean creation, the method name will be the object name in compiler. we can create our own name for bean.
Autowiring: 
	Autowire types - ByName, ByType, By Constructor and default 
	
Spring Bean Autowiring
The default autowire mode in XML configuration is no .
The default autowire mode in java configuration is byType .

		Compiler will look for by type initially. If by type matches more, it will look for by name ( bean name or the method name will be the object name in container ).
		If by name does not match, it will throw error. in case we need a diff variable name so that the bean name cant be matched, use 
		
		@Autowired
		@Qualifier("sl") // sl is a bean name
		StoreLocater sl5;
@Qualifier is not needed if you use same name of bean.

@component will create bean with camel case. 
Rest is same - bean name/methodname will be the created bean names. 
	
	We can create multiple bean for a same class if needed.
	
Scope : We can set at the class level or bean level as well. 
		- default is singleton. all 5 are singleton, prototype, request, session, global-session.
		- Whatever we set in class level ( default is singleton ), the bean scope should be lower order to that.
		Order : global-session --> Session --> Request --> Prototype --> Singleton
	
	
	
	
	
2021-05-29 :

@Configuration  should be  there for config class - main
@ComponentScan(basePackages = { "com.FaceBook.Locator" , "com.FaceBook.Service", "com.FaceBook.App"})// If all classes under (parent) this, this is not needed

PropertySource :
@PropertySource(value= {"classpath:/resources/application.properties"}) //To initialize the property value to be used in classes 
// Can be given multiple file seperated with comma // read more about it
-- This should be in confoguration class

	how to read the property ? 
	@Autowired
	Environment env;
	String name = env.getProperty("user.names");
	
	// Priority Order is  propertySources=[systemProperties,systemEnvironment,class path resource [resources/application.properties]]}
	
	
	
	
How NGP loads ?

The request when it comes, it will hit web.xml first since its a webmvc.
in web.xml we will have the disptacher servlet mapping.
	<servlet>
		<servlet-name>dispatch</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>dispatch</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping> 
	
	Similar to this, we can have n number of dispatcher servlet for our convenience(for diff paths. and as many dispatch{x}-servlet.xml 
	For all these dispatch servlet xmls, we can have a common xml for bean creation and other jobs which is called applicationcontext.xml.
	
	
How we can acheive this webmvc in java ? 

Create a class implementing WebApplicationInitializer
override onStartup
		AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); // see AnnotationConfigWebApplicationContext not AnnotationConfigApplicationContext
		context.register(WebConfigFile.class);
		ServletRegistration.Dynamic registerServlet = servletContext.addServlet("dispatcherServlet",
				new DispatcherServlet(context));
		registerServlet.setLoadOnStartup(1);
		registerServlet.addMapping("/");
		
In the WebConfigFile class need to have @configuration and @EnableWebMvc and @componenscan



@Profile - 

Based on profile name, we can initialise a bean
keep spring.profiles.active=testing for example 
and use @Profile("testing") to create bean only on test env. 

another way to set - context.getEnvironment().setActiveProfiles("production");

Profie vs environment - profile is or bean creation based on env. environment is simply to read properties. 

context.refresh() - Other than registering, if you need to set anything related to properties you need to refresh

View resolver : 2 things - 
1 - Used in ModelAndView to resolve the view name
2 - If @ResponseBody is not mentioned, compiler will not know how to send the response, then the view resolver will help to construct the response URL as below sample

	@ExceptionHandler(Exception.class)//unhandled exceptions will be handled here. 
	public String pleaseHandle(HttpServletRequest request, Exception e)
	{
		//return "/WEB-INF/views/error.jsp";//web assembly need to set with /webapp folder to access web pages - local config
		// This return statement will be as String "/WEB-INF/views/error.jsp" in browser if we use @RestController. because rest controller will consider this as string. 
		//If you use @controller you will be redirected to the respective jsp/html. In this case, we will have issue if we dont add @responsebody
		//view resolver can give option to give generic names. html/jsp etc
		return "error";// it will look for ViewResolver (in config file. in our case its InternalResourceViewResolver)
	}
	If @ResponseBody is there, text message will be given in response. 
	
	
	
2021-05-30

Annotations : 

@Controller = @Component belonging to Presentation Layer
@Service = @Component belonging to Service/Use Case Layer
@Repository = @Component belonging to Persistence Layer
@Component is generic for other stereotypes - like beans.
you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects.
For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.

@Controller is used to mark classes as Spring MVC Controller.
@RestController is a convenience annotation that does nothing more than adding the @Controller and @ResponseBody annotations (

@ResponseBody - This will just srite the response to the output stream and nothing else. In NGP, we dont do this way, we directly write to output stream.
In @responsebody we dont have any other attributes. 
Where we can set the produces, consumes details ? 
We can use Mapping annotations for that. 
	@GetMapping, @PostMapping, @RequestMapping
	
	@GetMapping(value = "/getproduct/{id}", consumes = "text/plain", produces = MediaType.APPLICATION_JSON_VALUE) -- application/json
		public String getMessage(@PathVariable String id) {
		return "Welcome :  " + id;
	}
	
	
If @responsebody is not given, Spring will not write it to output stream. It will look to resolve the response content. 
If its a string, it will look for resolving jsp
// This shoud be set in configuration class
	@Bean
	public InternalResourceViewResolver getResolved() { 
		InternalResourceViewResolver irvr = new InternalResourceViewResolver();
		irvr.setPrefix("/WEB-INF/views/");
		irvr.setSuffix(".jsp");
		return irvr;
	}
	
If response body given or not, This will work for ModelAndView same way. We can return ModelAndView as well in the response. 
	@GetMapping("/getproduct1") // same way we have postmapping and rest. latest usage
	public ModelAndView getMessage1() {
		ModelAndView mv = new ModelAndView("Welcome");
		mv.addObject("message1", "MESSAGE1");
		mv.addObject("message2", "MESSAGE2");
		return mv;
	}
For ModelAndView we dont need response body. 

<html>
<body>
	Welcome message is : ${message1}
	2nd Welcome message is : ${message2}
</body>
</html>

@component will be there on all below annotations
@Service
@Controller
@Repository
@RestController
@Configuration


List of annotations:
@component
@Service
@Controller
@Repository
@RestController
@Configuration

@RequestBody - we can have an object and whoever calls the service nedt o send that object. It will be used in POST. 
@ResponseBody
@GetMapping
@PostMapping
@RequestMapping
@PathVariable

@Bean
@Qualified
@Profile
@Autowired
@Scope
@ExceptionHandler
@RequestParam - @RequestParam(required = false, value = "geoKey") String geoKey or @RequestParam String geoKey ( but this is mandatory )
