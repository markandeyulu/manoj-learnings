IOC - In configuration class, we will have component scan -- whatever packages under wit, will be scanned for @component tag and that will be stored in spring container 
	and we can get that with getBean method of context.
	
Dependency injection : 

A bean which is already present in Spring container will be placed in another bean without calling "new" or getBean method. 
That will be injected automatically.

2 types : 
1. Constructor based
2. Setter based

Constructor based : 
In any class, when it get instantiated, If that class constructor has only the already present object from container, that will be injected. 

I am calling RentalService rentalService1 = (RentalService) context.getBean(RentalService.class);
Ex 
	RentalService(StoreLocater storeLocator) {
		this.storeLocator = storeLocator;
	}
	
	or 
	
		RentalService(StoreLocater storeLocator, StoreLocater test) {
		this.storeLocator = storeLocator;
		this.test = test;
	}
	
But below is not allowed since String is not a qualifying bean
RentalService(StoreLocater storeLocator, String test) {
		this.storeLocator = storeLocator;
		this.test = test;
	}
	
-- If 2 valid constructors present, compiler will look for default constructor only. 


Setter based injection : 
		
		RentalService rentalService1 = (RentalService) context.getBean(RentalService.class);		
		rentalService1.setStoreLocator(context.getBean(StoreLocater.class));  //context.getBean(StoreLocater.class) -- we do get the bean object from ontainer manually
		
		public void setStoreLocator(StoreLocater storeLocator) {
		System.out.println("Setter called");
		this.storeLocator = storeLocator;
			}
			
Autowired can be a replacement for both the above approaches : We can do the same simply using autowired
	@Autowired
	private StoreLocater storeLocator;
	
**Autowire - is not for premitive types and only for objects
	
Bean : 
What is Bean ? 
	Instead of compiler scans component on every class, we also can tell container to create a bean for a class and store it in a container. 
	
	During bean creation, the method name will be the object name in compiler. we can create our own name for bean.
Autowiring: 
	Autowire types - ByName, ByType, By Constructor and default 
	
Spring Bean Autowiring
The default autowire mode in XML configuration is no .
The default autowire mode in java configuration is byType .

		Compiler will look for by type initially. If by type matches more, it will look for by name ( bean name or the method name will be the object name in container ).
		If by name does not match, it will throw error. in case we need a diff variable name so that the bean name cant be matched, use 
		
		@Autowired
		@Qualifier("sl") // sl is a bean name
		StoreLocater sl5;
@Qualifier is not needed if you use same name of bean.

@component will create bean with camel case. 
Rest is same - bean name/methodname will be the created bean names. 
	
	We can create multiple bean for a same class if needed.
	
Scope : We can set at the class level or bean level as well. 
		- default is singleton. all 5 are singleton, prototype, request, session, global-session.
		- Whatever we set in class level ( default is singleton ), the bean scope should be lower order to that.
		Order : global-session --> Session --> Request --> Prototype --> Singleton
	
	
	
	
	
2021-05-29 :

@Configuration  should be  there for config class - main
@ComponentScan(basePackages = { "com.FaceBook.Locator" , "com.FaceBook.Service", "com.FaceBook.App"})// If all classes under (parent) this, this is not needed

PropertySource :
@PropertySource(value= {"classpath:/resources/application.properties"}) //To initialize the property value to be used in classes 
// Can be given multiple file seperated with comma // read more about it
-- This should be in confoguration class

	how to read the property ? 
	@Autowired
	Environment env;
	String name = env.getProperty("user.names");
	
	// Priority Order is  propertySources=[systemProperties,systemEnvironment,class path resource [resources/application.properties]]}
	
	
	
	
How NGP loads ?

The request when it comes, it will hit web.xml first since its a webmvc.
in web.xml we will have the disptacher servlet mapping.
	<servlet>
		<servlet-name>dispatch</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>dispatch</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping> 
	
	Similar to this, we can have n number of dispatcher servlet for our convenience(for diff paths. and as many dispatch{x}-servlet.xml 
	For all these dispatch servlet xmls, we can have a common xml for bean creation and other jobs which is called applicationcontext.xml.
	
	
How we can acheive this webmvc in java ? 

Create a class implementing WebApplicationInitializer
override onStartup
		AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); // see AnnotationConfigWebApplicationContext not AnnotationConfigApplicationContext
		context.register(WebConfigFile.class);
		ServletRegistration.Dynamic registerServlet = servletContext.addServlet("dispatcherServlet",
				new DispatcherServlet(context));
		registerServlet.setLoadOnStartup(1);
		registerServlet.addMapping("/");
		
In the WebConfigFile class need to have @configuration and @EnableWebMvc and @componenscan



@Profile - 

Based on profile name, we can initialise a bean
keep spring.profiles.active=testing for example 
and use @Profile("testing") to create bean only on test env. 

another way to set - context.getEnvironment().setActiveProfiles("production");

Profie vs environment - profile is or bean creation based on env. environment is simply to read properties. 

context.refresh() - Other than registering, if you need to set anything related to properties you need to refresh

View resolver : 2 things - 
1 - Used in ModelAndView to resolve the view name
2 - If @ResponseBody is not mentioned, compiler will not know how to send the response, then the view resolver will help to construct the response URL as below sample

	@ExceptionHandler(Exception.class)//unhandled exceptions will be handled here. 
	public String pleaseHandle(HttpServletRequest request, Exception e)
	{
		//return "/WEB-INF/views/error.jsp";//web assembly need to set with /webapp folder to access web pages - local config
		// This return statement will be as String "/WEB-INF/views/error.jsp" in browser if we use @RestController. because rest controller will consider this as string. 
		//If you use @controller you will be redirected to the respective jsp/html. In this case, we will have issue if we dont add @responsebody
		//view resolver can give option to give generic names. html/jsp etc
		return "error";// it will look for ViewResolver (in config file. in our case its InternalResourceViewResolver)
	}
	If @ResponseBody is there, text message will be given in response. 
	
	
	
2021-05-30

Annotations : 

@Controller = @Component belonging to Presentation Layer
@Service = @Component belonging to Service/Use Case Layer
@Repository = @Component belonging to Persistence Layer
@Component is generic for other stereotypes - like beans.
you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects.
For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.

@Controller is used to mark classes as Spring MVC Controller.
@RestController is a convenience annotation that does nothing more than adding the @Controller and @ResponseBody annotations (

@ResponseBody - This will just srite the response to the output stream and nothing else. In NGP, we dont do this way, we directly write to output stream.
In @responsebody we dont have any other attributes. 
Where we can set the produces, consumes details ? 
We can use Mapping annotations for that. 
	@GetMapping, @PostMapping, @RequestMapping
	
	@GetMapping(value = "/getproduct/{id}", consumes = "text/plain", produces = MediaType.APPLICATION_JSON_VALUE) -- application/json
		public String getMessage(@PathVariable String id) {
		return "Welcome :  " + id;
	}
	
	
If @responsebody is not given, Spring will not write it to output stream. It will look to resolve the response content. 
If its a string, it will look for resolving jsp
// This shoud be set in configuration class
	@Bean
	public InternalResourceViewResolver getResolved() { 
		InternalResourceViewResolver irvr = new InternalResourceViewResolver();
		irvr.setPrefix("/WEB-INF/views/");
		irvr.setSuffix(".jsp");
		return irvr;
	}
	
If response body given or not, This will work for ModelAndView same way. We can return ModelAndView as well in the response. 
	@GetMapping("/getproduct1") // same way we have postmapping and rest. latest usage
	public ModelAndView getMessage1() {
		ModelAndView mv = new ModelAndView("Welcome");
		mv.addObject("message1", "MESSAGE1");
		mv.addObject("message2", "MESSAGE2");
		return mv;
	}
For ModelAndView we dont need response body. 

<html>
<body>
	Welcome message is : ${message1}
	2nd Welcome message is : ${message2}
</body>
</html>

@component will be there on all below annotations
@Service
@Controller
@Repository
@RestController
@Configuration


List of annotations:
@component
@Service
@Controller
@Repository
@RestController
@Configuration

@RequestBody - we can have an object and whoever calls the service nedt o send that object. It will be used in POST. 
@ResponseBody
@GetMapping
@PostMapping
@RequestMapping
@PathVariable

@Bean
@Qualified
@Profile
@Autowired
@Scope
@ExceptionHandler
@RequestParam - @RequestParam(required = false, value = "geoKey") String geoKey or @RequestParam String geoKey ( but this is mandatory )


ServletContext --> Dispatcher --> AnnotationContext(Webconfig file)


Handler Mapping : 

HandlerMapping is an interface that defines a mapping between requests and handler objects.

BeanNameUrlHandlerMapping:

By default handler mapping is BeanNameUrlHandlerMapping and DefaultAnnotationHandlerMapping.
 In config file

 @Bean
	public BeanNameUrlHandlerMapping getBeanNameUrlHandlerMapping() {
		return new BeanNameUrlHandlerMapping();
	}
	
	@Bean("/testbeannamemapping*")
	public ProductController2 getProductController2() {
		return new ProductController2();
	}
	
	-- now if we recive any request as /testbeannamemapping*, it will be redicted to ProductController2. In ProductController2, that should extend the AbstractContrller and we have override a method called handleRequestInternal
	
	@Override
	 protected ModelAndView handleRequestInternal(HttpServletRequest request,
	            HttpServletResponse response) throws Exception {
		ModelAndView mv = new ModelAndView("Welcome");
		mv.addObject("message1", "MESSAGE1");
		mv.addObject("message2", "MESSAGE2");
		return mv;
	}
	
	-- Bean name does not need to be started with /.
	
	
SimpleUrlHandlerMapping : 

Its straight forward. We can use this handler mapping to map the url name to bean name of the controller(case sensitive). 
	@Bean
	public SimpleUrlHandlerMapping getSimpleUrlHandlerMapping() {
		SimpleUrlHandlerMapping shm = new SimpleUrlHandlerMapping();
		Properties mappings = new Properties();
		mappings.setProperty("marktestsimpleURL", "ProductController2");
		shm.setMappings(mappings);
		return shm;
	}
	
	-- Bean name does not need to be started with /.Its an optional. /marktestsimpleURL or marktestsimpleURL.
	
ControllerClassNameHandlerMapping:

	@Bean
	public ControllerClassNameHandlerMapping getControllerClassNameHandlerMapping() {
		return new ControllerClassNameHandlerMapping();
	}
	If the controller is HelloController, we can give url with /hello, /helloWorld anything like that should work. 
	Additionally, you can specify a prefix to maps the requested URL, declared a “pathPrefix” property.
	In case if we dont want to be case sensitive, we can set a propertu to make it false. 
	by default I think its true. 


DefaultAnnotationHandlerMapping
 - Implementation of the HandlerMapping interface that maps handlers based on HTTP paths expressed through the RequestMapping annotation at the type or method level.
 - This later replaced by RequestMappingHandlerMapping
 - You should replace those classes by RequestMappingHandlerMapping and RequestMappingHandlerAdapter if you are using Spring 3.1 and higher. 


Handler adapters in Spring mvc : 
SimpleControllerHandlerAdapter - default
SimpleServletHandlerAdapter
HttpRequestHandlerAdapter
AnnotationMethodHandlerAdapter - default
later replaced by RequestMappingHandlerAdapter - default



How to set bean paramter as default - 	public ProductDAO(@Value("sabari") String name) {
How to set request mapping with default value -     String getName(@RequestParam(value = "person", defaultValue = "John") String personName) {

The default value in @RequestParam will always be String though the variable is int. It will to parsing internally.


@ControllerAdvice
 Golabl exception handling - Single point of exception handling from multiple Back controllers
 		//you can have the same Exception handler@ExceptionHandler in controller as well. But priority will be given to that BC instead of Common handler. Hirarchy is important.
		// parallel to this you can handle the exceptions in BC as well.
	
	@ExceptionHandler({ProductNotFoundException.class}) // arg classes can be multiple with comma. Exception.class also can be given
	
		@ExceptionHandler({ProductNotFoundException.class}) 
	public ModelAndView handleProductException(Exception ex) {
		ModelAndView mv = new ModelAndView("error", "ex", ex);
		mv.addObject("ex", ex);*///another way
		return mv;
	}
	
	
Spring JDBC : 

Its fairly simple. We will create a bean for JDBCTemplate.
But can we create the JDBCTemplate source automatically thru property ? - No.
We have to create the Datasource ( ex - DriverManagerDataSource from Spring JDBC ) and set it into JDBC bean creation. 

Then we can use that bean to call update/execute usig queries. create not supported. 


	
	@Bean //Spring JDBC 
	public DataSource getSource() {//javax.sql.DataSource //oracle wont support to give jar via maven.
		// Add the JDBC jar library in deployment assembly too
		// DataSource dataDource = new DataSource();
		BasicDataSource dataSource = new BasicDataSource();//extended tomcat datasource
		
		dataSource.setDriverClassName("oracle.jdbc.OracleDriver");
		dataSource.setUrl("jdbc:oracle:thin:@10.30.130.52:1521:orcl");//type 4 driver of JDBC. what are other types ?
		dataSource.setUsername("test31");
		dataSource.setPassword("oracle");
		//dataSource.getConnection().setAutoCommit(false);//If you want autocommit to set false
		return dataSource;//In Spring JDBC, hiberbnate etc etc, we need this Datasource
		
	}
	
	
	@Bean // this JDBC template available in Spring JDBC maven jar. Oracle Datasource only not in Maven.
	public JdbcTemplate getTemplate() { // will be defaultly taken by JdbcTemplate
	
		JdbcTemplate jdbcTemplate = new JdbcTemplate(getSource());
		//jdbcTemplate.getDataSource().getConnection().setAutoCommit(false); If you need autoCommnit false. By default its true
		return jdbcTemplate;
	}
	